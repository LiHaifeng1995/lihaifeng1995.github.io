{"meta":{"title":"随手小记","subtitle":null,"description":null,"author":"李海峰","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2018-05-26T12:41:54.327Z","updated":"2018-05-26T12:41:54.327Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-05-27T11:57:06.094Z","updated":"2018-05-26T12:42:45.839Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BFC及其作用","slug":"BFC及其作用","date":"2018-06-25T14:08:48.000Z","updated":"2018-06-29T14:00:54.686Z","comments":true,"path":"2018/06/25/BFC及其作用/","link":"","permalink":"http://yoursite.com/2018/06/25/BFC及其作用/","excerpt":"","text":"BFC是什么？","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"BFC","slug":"BFC","permalink":"http://yoursite.com/tags/BFC/"},{"name":"CSS布局","slug":"CSS布局","permalink":"http://yoursite.com/tags/CSS布局/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"},{"name":"外边距重叠","slug":"外边距重叠","permalink":"http://yoursite.com/tags/外边距重叠/"},{"name":"自适应两栏布局","slug":"自适应两栏布局","permalink":"http://yoursite.com/tags/自适应两栏布局/"}]},{"title":"视频监控领域无插件播放完整解决方案","slug":"视频监控领域无插件播放完整解决方案","date":"2018-06-07T14:37:46.000Z","updated":"2018-07-10T14:43:03.444Z","comments":true,"path":"2018/06/07/视频监控领域无插件播放完整解决方案/","link":"","permalink":"http://yoursite.com/2018/06/07/视频监控领域无插件播放完整解决方案/","excerpt":"不同于普通的网站直播，视频监控领域的直播需要支持各种参数，对实时性的要求也更高，因此，视频监控需要采用更加复杂的解决方案。","text":"不同于普通的网站直播，视频监控领域的直播需要支持各种参数，对实时性的要求也更高，因此，视频监控需要采用更加复杂的解决方案。 解码要求 需要支持多种编码格式，如H.264, H.265,智能编码，SVC， 高帧率等。 需要支持多种音频格式。 需要支持多种分辨率， 高帧率等。 对实时性要求更高。 基于以上要求，采用FFMPEG + MSE 的综合解码方案。原因如下： FFMPEG支持标准H264, H265解码，MSE仅支持H264。 FFMPEG支持智能编码，MSE不支持。 js解码能力较弱，在高分辨率时很容易碰到性能瓶颈，故采用MSE作为高分辨率时的解码方案。 FFMPEG和MSE的实时性要求都比较好。 对于音频，G711和G726采用window.AudioContext来进行处理，AAC同样使用MSE进行处理。 具体实现FFMPEGFFMPEG是用来处理音视频数据的一套开源程序，应用广泛(事实上大部分编解码方案都基于ffmpeg)，使用Emscripten将FFMPEG源码转为asm.js，以供在web端进行视频解码。不使用wasm的原因是因为其对浏览器版本要求较高，为了兼容性不得不做一些放弃。FFMPEG将视频数据转化为YUV格式，并使用WEBGL绘制。 MSEMedia Source Extensions（媒体源扩展 API）提供了实现无插件且基于 Web 的流媒体的功能。使用 MSE，媒体串流能够通过 JavaScript 创建，并且能通过使用 &lt;audio&gt; 和 &lt;video&gt; 元素进行播放。 方案选择使用FFMPEG时可以不使用缓存机制，因此对延时可以控制的更好。综合考虑FFMPEG在web端解码能力不足以及监控对实时性的要求，故采用如下方案： 在低分辨率时(720P以及以下)，采用FFMPEG解码，做到极低的延时，300ms左右；在高分辨率时，采用MSE方式，将媒体数据组装为MP4，来播放视频, 此时延时在600-800ms左右，支持4K分辨率。在H265模式下， 仅采用FFMPEG解码，一旦超出解码能力，则切换到辅码流（低分辨率）播放。在智能编码开启时，仅使用FFMPEG解码，因为MSE不支持智能编码。 在高分辨时，采用时域可分级的编码也可以采用丢帧策略，一方面保证视频能在web端正常播放，另一方面也不影响NVR等设备存储视频。 缓存控制当每一帧数据处理完毕时，上一帧数据不一定播放完成，在这两帧的时间内(duration)，要将下一帧的数据保存起来，因此，要做一定的缓存控制。 FFMPEG通过FFMPEG解码后的YUV数据，先将其放到一段Buffer中，通过window.requestanimationframe接口来判断绘制下一帧的时机： 1234567//currentTime表示当前帧时间戳，lastTime表示上一帧时间戳，duration为1000/帧率var drawFrame = function() &#123; if(currentTime - lastTime &gt;= duration) &#123; draw()//绘制一帧 &#125; window.requestanimationframe(drawFrame);&#125; 当两帧的时间戳插值大于等于duration时，表示该进行播放下一帧了。 使用FFMPEG + WEBGL的方式，缓存仅有一次，即保存解码后的YUV数据，而使用MSE则有两次缓存。 MSE第一次缓存在sourceBuffer中，有一个updating事件，表示该对象正在更新，不能做appendBuffer操作，因此，当此时有数据需要缓存时，暂时将其放在一个buffer对象中： 123456789101112131415161718function appendSegment(mediaData) &#123; if(sourceBuffer == null) &#123; return; &#125; if(mediaSource.readyState === 'closed' || mediaSource.readyState === 'ended') &#123; return; &#125; if(segmentBuffer.length &gt; 0) &#123; //segmentBuffer长度大于0说明还有数据待放入sourceBuffer segmentBuffer.push(mediaData); &#125;else &#123; if(!sourceBuffer.updating) &#123; //sourceBuffer未处于更新状态时，将数据放到sourceBuffer中 sourceBuffer.appendBuffer(mediaData); &#125;else &#123; segmentBuffer.push(mediaData); &#125; &#125;&#125; 何时取出？ sourceBuffer有一个’update’事件，每更新一次后触发该事件，因此，可以在该事件的回调函数中将视频数据放入sourceBuffer，具体代码如下：1234567function onSourceBufferUpdate(mediaData) &#123; if(segmentBuffer.length &gt; 0) &#123; if(!sourceBuffer.updating) &#123; sourceBuffer.appendBuffer(segmentBuffer.shift()); &#125; &#125;&#125; 经实测，MSE使用此种方法，segmentBuffer.length一般都在5之内(内网环境较为稳定)。 第二次缓存第二次缓存发生在appendBuffer之后，MSE解码需要得到一段时间的数据，故产生缓存。这一部分的缓存一般默认在2到3秒，因此，减少这一部分的缓存可以极大的减小延时。 延时优化video标签支持多个事件，其中，waiting表示当前无法继续播放，需要加载数据，canplaythrough表示可以无需等待继续播放，durationchange表示持续时间改变，即视频长度改变，我们可以利用这几个事件做一定的跳秒操作，以减小视频的延时： 12345678910111213141516171819function onDurationChange() &#123; if(sourceBuffer == null) &#123; return; &#125; //ctrlDelay用来控制跳秒操作开启 if(ctrlDelay)&#123; var startTime = sourceBuffer.buffered.start(0); var endTime = sourceBuffer.buffered.end(0); var diffTime = videoElement.currentTime ? endTime - videoElement.currentTime : endTime - startTime; if(diffTime &gt;= delay + 0.1) &#123; // delay用来控制延时大小，+0.1是为了保证每次跳秒0.1S以上，以防止执行次数过多 if(sourceBuffer.updating) &#123; return; &#125; videoElement = (endTime - delay).toFixed(2); &#125; &#125;&#125; 通过设置delay的大小，可以控制延时的大小。 在刚加载数据时，如果立即调用该回调，则可能引起不断跳秒，卡顿的问题，原因是视频未准备好播放(!canplaythrough)，因此我们可以在canplaythrough事件的回调中开启跳秒操作： 123function onCanplayThrough() &#123; ctrlDelay = true;&#125; 遇到网络抖动或者其他状况时，可能会导致视频暂时不能够继续播放，此时触发waiting事件，在该事件的回调函数中，关闭跳秒的检测，以防止产生问题： 123function onWaiting() &#123; ctrlDelay = false;&#125; 若因硬件性能问题或者网络问题等，不断引发跳秒操作，则应增加delay的值，以防止出现该问题： 12345678910111213141516var waitingCount = 0;function onWaiting() &#123; ctrlDelay = false; if(waitingCount == 0) &#123; firstTime = Date.now(); waitingCount ++; &#125;else &#123; waitingCount ++; var diffTime = Date.now() - firstTime; if(waitingCount &gt;= 5 &amp;&amp; diffTime &lt; 60000) &#123; delay = delay + 0.1; waitingCount = 0; &#125; &#125;&#125; 此处采用了一分钟内触发5次waiting事件时，delay + 0.1 的处理方式。技术和经验有限，暂时还未找到更佳的处理方式。同时，delay只能动态增加，也不能做动态减少，希望以后能够找到好的处理方式来解决。 经实测，使用上述延时优化策略，当网络状况良好时，在1080P-4K分辨率，25帧时，都仅需执行一次跳秒操作即可将延时降低到1s内。 总结使用上述方式，基本上能涵盖视频监控领域大部分的情况。因技术有限，文章内难免有不足的地方，欢迎指正。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"},{"name":"直播","slug":"Javascript/直播","permalink":"http://yoursite.com/categories/Javascript/直播/"}],"tags":[{"name":"H5直播","slug":"H5直播","permalink":"http://yoursite.com/tags/H5直播/"},{"name":"低延时","slug":"低延时","permalink":"http://yoursite.com/tags/低延时/"},{"name":"H264","slug":"H264","permalink":"http://yoursite.com/tags/H264/"},{"name":"高清","slug":"高清","permalink":"http://yoursite.com/tags/高清/"},{"name":"视频","slug":"视频","permalink":"http://yoursite.com/tags/视频/"}]},{"title":"MSE直播方案调优","slug":"MSE直播方案调优","date":"2018-06-07T14:23:27.000Z","updated":"2018-07-09T15:34:31.157Z","comments":true,"path":"2018/06/07/MSE直播方案调优/","link":"","permalink":"http://yoursite.com/2018/06/07/MSE直播方案调优/","excerpt":"时隔一个月，项目即将到尾声，现在回过头来看当时记录的问题，甚至想要删掉(现在看当时遇到的问题停蠢的)，仔细想想，这都是自己的宝贵经历，还是留下当作纪念","text":"时隔一个月，项目即将到尾声，现在回过头来看当时记录的问题，甚至想要删掉(现在看当时遇到的问题停蠢的)，仔细想想，这都是自己的宝贵经历，还是留下当作纪念 此篇主要介绍博主在开发基于MSE方案的直播项目中，进行的策略优化。 在近期的一个项目中，需要使用MSE进行视频的播放。相关资料本就少，完整参考仅有一份官方的英文文档。因此，笔者踩了很多坑，才将此项目完善。最初遇到的问题，大致分为以下几个： 偶尔出现回退现象 进度条显示时间和实际不一致 视频卡顿，无明显规律 延时过大(超过1秒) 时间戳第一个问题主要是由于未打入时间戳引起(fmp4好像有两种封装格式，另一种不需要打入时间戳，但是要保证传输的顺序)，导致MSE不能正确识别播放顺序，在打入时间戳后，不再出现这个问题，但是出现了下一个，心累。。。。。。。 frameDuration baseMediaDecodeTime在花了很久时间搞清楚frameDuration和baseMediaDecodeTime的含义后（楼主对之前对音视频方面是0基础的小白，网上的资料只简单的翻译了一下，都是泪），把这两个参数打入到封装FMP4的接口后，出现了进度条显示时间和实际不一致的问题，具体表现为播放视频10秒，进度条只走了1秒，video.currentTime中表现也如此。最终，把baseMediaDecodeTime的值*10才正常的显示(直到现在也没搞懂原因，捂脸)。 缓存控制在解决了以上两个问题后，出现了最麻烦的问题，经常性的出现视频的卡顿，并且有时能跳秒追上，大部分时候不能够追上。查阅N篇资料后，一直没有头绪，最后，感谢同项目组的一位大佬，帮助我找出了问题。原因很简单，网上对于MSE的教程中有这么一段代码： 123if (this.sourceBuffer.updating)&#123;//上一块数据还在添加中 return;&#125; 当sourceBuffer处于updating的状态时，直接返回了，返回了…..导致了该数据块直接丢失，其中包含N个帧。类似代码在网上各种教程中泛滥，几乎都是这么写，误导了多少小白- - 一言难尽。 解决方案如下： 在此处添加一个buffer，用于存储外部传入的数据块。当sourceBuffer处于updating的状态，先将数据传入buffer中，之后，每次updateend时，从该buffer中取出数据传入SourceBuffer中，若为空，则直接等待外部数据传入(今天写这篇文章时，发现stackoverflow上已经有此方法，之前看到英文不想读)。具体代码如下： 1待填坑 跳秒解决延时问题在该项目中，最初播放延时有3秒左右，无奈领导要求必须控制在1秒内，只能想办法解决。 解决延时问题，主要有以下几种方法： 无缓存 控制播放速度，缓存较大时增大倍速 跳秒 第一种，对于MSE好像不能实现，MSE必须要有缓存机制(如果我说错了，欢迎指正)，因此，第一个方法直接放弃。 第二种，尝试过，但是，当currentTime和souceBuffer.buffered.end(0)的差值很小时，视频会出现明显的卡顿，需要等待一段时间才能继续播放，因此，使用控制倍速的方式，会出现快放–卡顿–快放–卡顿不断循环的过程。 第三种，待补坑，明天写。。。。。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"},{"name":"直播","slug":"Javascript/直播","permalink":"http://yoursite.com/categories/Javascript/直播/"}],"tags":[{"name":"H5直播","slug":"H5直播","permalink":"http://yoursite.com/tags/H5直播/"},{"name":"低延时","slug":"低延时","permalink":"http://yoursite.com/tags/低延时/"},{"name":"H264","slug":"H264","permalink":"http://yoursite.com/tags/H264/"},{"name":"高清","slug":"高清","permalink":"http://yoursite.com/tags/高清/"},{"name":"视频","slug":"视频","permalink":"http://yoursite.com/tags/视频/"}]},{"title":"H5低延时直播方案","slug":"H5低延时直播方案","date":"2018-05-28T15:26:34.000Z","updated":"2018-07-08T14:39:26.725Z","comments":true,"path":"2018/05/28/H5低延时直播方案/","link":"","permalink":"http://yoursite.com/2018/05/28/H5低延时直播方案/","excerpt":"本文主要比较几种常用的直播方案，以及笔者在项目开发中使用过的方案，具体细节不做分析。","text":"本文主要比较几种常用的直播方案，以及笔者在项目开发中使用过的方案，具体细节不做分析。当前，直播方案有如下几种： HLS HTTP Live Streaming（简称 HLS）是一个基于 HTTP 的视频流协议，由 Apple 公司实现。其采用将视频切片的方式，将编码好的TS文件切成等长的ts文件。在刚开始拉流时，需要缓存至少3个ts文件，每个ts文件长2s，因此，会产生6s以上的延时。 HLS有以下优缺点： 移动端支持良好，IOS、Android都支持HLS, 常用的QuickTime VLC等播放器也对HLS有良好的支持性。 PC端浏览器支持情况不佳。 延时较大，仅支持要求实时性不高的场景。 不支持H265 RTMPRTMP是Adobe公司开发的一套视频直播协议，基于flash，因此，无法在ios的浏览器中使用,但是其实时性较好，延时可以低至两秒。 下面是HLS和RTMP协议的对比： 如上两种方案已支持大部分的使用场景，但是，在对实时性要求更高的应用场景，例如，视频监控等，上面两种协议也不能够满足使用要求。下面介绍两种延时更低的方案： RTSP RTSP（实时流协议，Real Time Streaming Protocol）是由Real Network和Netscape共同提出的如何有效地在IP网络上传输流媒体数据的应用层协议。RTSP对流媒体提供了诸如暂停，快进等控制，而它本身并不传输数据，RTSP的作用相当于流媒体服务器的远程控制。 基于RTSP协议，我们可以使用RTP（实时传输协议，Real-time Transport Protocol）来进行流媒体数据的传输，RTP协议具有极低的延时性。在浏览器收到RTP数据包后，视频解析阶段我们可以采用如下两种方案： FFMPEG + WEBGLFFmpeg是一套开源程序，它提供了录制、转换以及流化音视频的完整解决方案。我们可以使用asm或者wasm将FFmpeg转为可在浏览器执行的解码库，通过FFMpeg将经由RTP协议传输的视频数据转码，并通过WEBGL绘制。 使用此种方案有以下优缺点： 在解码能力足够时，播放延时极低，实测可在0.3s以内。 FFMpeg在浏览器端解码，软解极耗性能，1080P下，只能到10帧左右。 asm支持情况较为完善，wasm要在极新版本的浏览器才支持（具体版本需测试） 解码后的数据对开发者来说不再是黑盒，为对视频进行进一步处理提供了便利。 支持H.265解码！目前，基于浏览器直接支持解码的各种方案都不支持H.265解码。 MSEMedia Source Extensions（媒体源扩展）提供了实现无插件且基于 Web 的流媒体的功能。使用 MSE，媒体串流能够通过 JavaScript 创建，并且能通过使用 &lt;audio&gt; 和 &lt;video&gt; 元素进行播放。 在通过拿到RTP包后，我们可以将其组装成fMP4，并喂到video中播放。 使用这种方案，可以解决FFMpeg软解性能不足的问题，实现高分辨率下的流畅播放，在实时性上略差，延时可以控制在1s左右。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"},{"name":"直播","slug":"Javascript/直播","permalink":"http://yoursite.com/categories/Javascript/直播/"}],"tags":[{"name":"H5直播","slug":"H5直播","permalink":"http://yoursite.com/tags/H5直播/"},{"name":"低延时","slug":"低延时","permalink":"http://yoursite.com/tags/低延时/"},{"name":"H264","slug":"H264","permalink":"http://yoursite.com/tags/H264/"},{"name":"视频","slug":"视频","permalink":"http://yoursite.com/tags/视频/"},{"name":"H265","slug":"H265","permalink":"http://yoursite.com/tags/H265/"}]},{"title":"浅谈深拷贝和浅拷贝","slug":"浅谈深拷贝和浅拷贝","date":"2018-05-27T13:25:42.000Z","updated":"2018-05-29T14:19:53.548Z","comments":true,"path":"2018/05/27/浅谈深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2018/05/27/浅谈深拷贝和浅拷贝/","excerpt":"","text":"待补坑…….","categories":[],"tags":[]},{"title":"canvas标签width和style.width的区别","slug":"canvas标签width和style-width的区别","date":"2018-05-26T12:46:01.000Z","updated":"2018-05-29T13:45:58.677Z","comments":true,"path":"2018/05/26/canvas标签width和style-width的区别/","link":"","permalink":"http://yoursite.com/2018/05/26/canvas标签width和style-width的区别/","excerpt":"Canvas大小的修改有三种方法：","text":"Canvas大小的修改有三种方法：方法一： 通过CSS样式来控制canvas元素，具体代码如下： 1canvas &#123; width: 600px; height: 300px&#125; 方法二： 直接在canvas标签内定义width和height，具体代码如下： 1&lt;canvas width='600' height='300'&gt;&lt;/canvas&gt; 方法三： 在JS代码里面设置width和height， 在var ctx = myCanvas.getContext(&#39;2d&#39;) 后面追加如下代码： 12myCanvas.width = 600;myCanvas.height = 300; 设置canvas标签css的width属性，和直接设置canvas的width属性，结果是不一样的。原因如下： canvas标签包含元素本身以及元素绘图表面，它们各自有自己的尺寸大小。当直接设置canvas标签的width时，会同时改变元素本身的大小和元素绘图表面的大小，此时，显示效果不发生改变(只有等比例变化)；设置canvas css中width的属性时，只改变canvas本身的大小，而不改变元素绘图表面的大小，此时，元素绘图表面为适应canvas元素的尺寸，会进行拉伸或缩小，导致显示效果变化。 height 和 style.height 同理。 感谢 ‘https://www.cnblogs.com/regina1123/p/6234719.html&#39;","categories":[{"name":"html","slug":"html","permalink":"http://yoursite.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]}