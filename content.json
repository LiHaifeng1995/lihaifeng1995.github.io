{"meta":{"title":"随手小记","subtitle":null,"description":null,"author":"李海峰","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-05-27T11:57:06.094Z","updated":"2018-05-26T12:42:45.839Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-26T12:41:54.327Z","updated":"2018-05-26T12:41:54.327Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"BFC及其作用","slug":"BFC及其作用","date":"2018-06-25T14:08:48.000Z","updated":"2018-08-24T12:47:22.063Z","comments":true,"path":"2018/06/25/BFC及其作用/","link":"","permalink":"http://yoursite.com/2018/06/25/BFC及其作用/","excerpt":"BFC是什么？","text":"BFC是什么？ 在解释BFC之前，需要先了解BOX、Formatting Context的概念。 Box：CSS布局的基本单位Box是CSS布局的对象和基本单位，直观点说，就是一个页面是由很多个Box组成的。元素的类型和display属性，决定了这个Box的类型。不同类型的Box，会参与不同的Formatting Context（一个决定如何渲染文档的容器），因此，Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box：display属性未block，list-item，table的元素，会生成block-level box。并且参与 block formatting context inline-level box：display属性为inline，inline-block，inline-table的元素，会生成inline-level box，并参与inline formatting context run-in box：css3中才有，这儿先不讲了 Formatting contextFormatting context是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和互相作用。最常见的Formatting context有Block formatting context（简称BFC）和Inline formatting context（IFC）。 CSS2.1中只有BFC和IFC，CSS3中还增加了GFC和FFC。 BFC定义BFC直译为“块级格式化上下文”，它是一个独立的渲染区域，只有Block-level box参与，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。 BFC的区域不会与float box 重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。 计算BFC的高度时，浮动元素也参与计算。 哪些元素会生成BFC？ 根元素 float属性不为none position为absolute或fixed display为inline-block，table-cell， table-caption， flex， inline-flex overflow不为visible BFC的作用及原理自适应两栏布局12345678910111213141516171819202122&lt;style&gt; body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/body&gt; 页面： 根据BFC布局规则第三条： 每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。 因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。 根据BFC布局规则第四条： BFC的区域不会与float box重叠。 因此，我们可以通过使main生成BFC，来实现自适应两栏布局： 123.main &#123; overflow: hidden;&#125; 当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下： 清除内部浮动代码：12345678910111213141516171819&lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 页面： 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 为了达到清除内部浮动的目的，我们可以触发par生成BFC。代码：123.par &#123; overflow: hidden;&#125; 效果如下： 防止垂直margin重叠代码：1234567891011121314&lt;style&gt; .test &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p class=\"test\"&gt;Haha&lt;/p&gt; &lt;p class=\"test\"&gt;Hehe&lt;/&gt;&lt;/body&gt; 页面： 两个p之间的距离为100px，发生了margin重叠。 根据BFC布局规则第二条： Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外卖包裹一层容易，并使其生成一个BFC，那么两个P便不属于同一个BFC，就不会发生margin重叠了。 代码：12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden; &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=\"wrap\"&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 效果如下： 总结其实，以上的几个例子都体现了BFC布局规则第五条： BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦如此。 因为BFC内部的元素和外部的元素绝对不会相互影响，因此，当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度，避免margin重叠也是这样的一个道理。 原文来自： 前端精选文摘：BFC 神奇背后的原理","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"BFC","slug":"BFC","permalink":"http://yoursite.com/tags/BFC/"},{"name":"CSS布局","slug":"CSS布局","permalink":"http://yoursite.com/tags/CSS布局/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"},{"name":"外边距重叠","slug":"外边距重叠","permalink":"http://yoursite.com/tags/外边距重叠/"},{"name":"自适应两栏布局","slug":"自适应两栏布局","permalink":"http://yoursite.com/tags/自适应两栏布局/"}]},{"title":"视频监控领域无插件播放完整解决方案","slug":"视频监控领域无插件播放完整解决方案","date":"2018-06-07T14:37:46.000Z","updated":"2018-07-12T13:54:42.709Z","comments":true,"path":"2018/06/07/视频监控领域无插件播放完整解决方案/","link":"","permalink":"http://yoursite.com/2018/06/07/视频监控领域无插件播放完整解决方案/","excerpt":"不同于普通的网站直播，视频监控领域的直播需要支持各种参数，对实时性的要求也更高，因此，视频监控需要采用更加复杂的解决方案。","text":"不同于普通的网站直播，视频监控领域的直播需要支持各种参数，对实时性的要求也更高，因此，视频监控需要采用更加复杂的解决方案。考虑到部分内容涉及到未发布的项目，暂时隐藏，望谅解。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"},{"name":"直播","slug":"Javascript/直播","permalink":"http://yoursite.com/categories/Javascript/直播/"}],"tags":[{"name":"H5直播","slug":"H5直播","permalink":"http://yoursite.com/tags/H5直播/"},{"name":"低延时","slug":"低延时","permalink":"http://yoursite.com/tags/低延时/"},{"name":"H264","slug":"H264","permalink":"http://yoursite.com/tags/H264/"},{"name":"高清","slug":"高清","permalink":"http://yoursite.com/tags/高清/"},{"name":"视频","slug":"视频","permalink":"http://yoursite.com/tags/视频/"}]},{"title":"MSE直播方案调优","slug":"MSE直播方案调优","date":"2018-06-07T14:23:27.000Z","updated":"2018-07-09T15:34:31.157Z","comments":true,"path":"2018/06/07/MSE直播方案调优/","link":"","permalink":"http://yoursite.com/2018/06/07/MSE直播方案调优/","excerpt":"时隔一个月，项目即将到尾声，现在回过头来看当时记录的问题，甚至想要删掉(现在看当时遇到的问题停蠢的)，仔细想想，这都是自己的宝贵经历，还是留下当作纪念","text":"时隔一个月，项目即将到尾声，现在回过头来看当时记录的问题，甚至想要删掉(现在看当时遇到的问题停蠢的)，仔细想想，这都是自己的宝贵经历，还是留下当作纪念 此篇主要介绍博主在开发基于MSE方案的直播项目中，进行的策略优化。 在近期的一个项目中，需要使用MSE进行视频的播放。相关资料本就少，完整参考仅有一份官方的英文文档。因此，笔者踩了很多坑，才将此项目完善。最初遇到的问题，大致分为以下几个： 偶尔出现回退现象 进度条显示时间和实际不一致 视频卡顿，无明显规律 延时过大(超过1秒) 时间戳第一个问题主要是由于未打入时间戳引起(fmp4好像有两种封装格式，另一种不需要打入时间戳，但是要保证传输的顺序)，导致MSE不能正确识别播放顺序，在打入时间戳后，不再出现这个问题，但是出现了下一个，心累。。。。。。。 frameDuration baseMediaDecodeTime在花了很久时间搞清楚frameDuration和baseMediaDecodeTime的含义后（楼主对之前对音视频方面是0基础的小白，网上的资料只简单的翻译了一下，都是泪），把这两个参数打入到封装FMP4的接口后，出现了进度条显示时间和实际不一致的问题，具体表现为播放视频10秒，进度条只走了1秒，video.currentTime中表现也如此。最终，把baseMediaDecodeTime的值*10才正常的显示(直到现在也没搞懂原因，捂脸)。 缓存控制在解决了以上两个问题后，出现了最麻烦的问题，经常性的出现视频的卡顿，并且有时能跳秒追上，大部分时候不能够追上。查阅N篇资料后，一直没有头绪，最后，感谢同项目组的一位大佬，帮助我找出了问题。原因很简单，网上对于MSE的教程中有这么一段代码： 123if (this.sourceBuffer.updating)&#123;//上一块数据还在添加中 return;&#125; 当sourceBuffer处于updating的状态时，直接返回了，返回了…..导致了该数据块直接丢失，其中包含N个帧。类似代码在网上各种教程中泛滥，几乎都是这么写，误导了多少小白- - 一言难尽。 解决方案如下： 在此处添加一个buffer，用于存储外部传入的数据块。当sourceBuffer处于updating的状态，先将数据传入buffer中，之后，每次updateend时，从该buffer中取出数据传入SourceBuffer中，若为空，则直接等待外部数据传入(今天写这篇文章时，发现stackoverflow上已经有此方法，之前看到英文不想读)。具体代码如下： 1待填坑 跳秒解决延时问题在该项目中，最初播放延时有3秒左右，无奈领导要求必须控制在1秒内，只能想办法解决。 解决延时问题，主要有以下几种方法： 无缓存 控制播放速度，缓存较大时增大倍速 跳秒 第一种，对于MSE好像不能实现，MSE必须要有缓存机制(如果我说错了，欢迎指正)，因此，第一个方法直接放弃。 第二种，尝试过，但是，当currentTime和souceBuffer.buffered.end(0)的差值很小时，视频会出现明显的卡顿，需要等待一段时间才能继续播放，因此，使用控制倍速的方式，会出现快放–卡顿–快放–卡顿不断循环的过程。 第三种，待补坑，明天写。。。。。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"},{"name":"直播","slug":"Javascript/直播","permalink":"http://yoursite.com/categories/Javascript/直播/"}],"tags":[{"name":"H5直播","slug":"H5直播","permalink":"http://yoursite.com/tags/H5直播/"},{"name":"低延时","slug":"低延时","permalink":"http://yoursite.com/tags/低延时/"},{"name":"H264","slug":"H264","permalink":"http://yoursite.com/tags/H264/"},{"name":"高清","slug":"高清","permalink":"http://yoursite.com/tags/高清/"},{"name":"视频","slug":"视频","permalink":"http://yoursite.com/tags/视频/"}]},{"title":"H5低延时直播方案","slug":"H5低延时直播方案","date":"2018-05-28T15:26:34.000Z","updated":"2018-07-08T14:39:26.725Z","comments":true,"path":"2018/05/28/H5低延时直播方案/","link":"","permalink":"http://yoursite.com/2018/05/28/H5低延时直播方案/","excerpt":"本文主要比较几种常用的直播方案，以及笔者在项目开发中使用过的方案，具体细节不做分析。","text":"本文主要比较几种常用的直播方案，以及笔者在项目开发中使用过的方案，具体细节不做分析。当前，直播方案有如下几种： HLS HTTP Live Streaming（简称 HLS）是一个基于 HTTP 的视频流协议，由 Apple 公司实现。其采用将视频切片的方式，将编码好的TS文件切成等长的ts文件。在刚开始拉流时，需要缓存至少3个ts文件，每个ts文件长2s，因此，会产生6s以上的延时。 HLS有以下优缺点： 移动端支持良好，IOS、Android都支持HLS, 常用的QuickTime VLC等播放器也对HLS有良好的支持性。 PC端浏览器支持情况不佳。 延时较大，仅支持要求实时性不高的场景。 不支持H265 RTMPRTMP是Adobe公司开发的一套视频直播协议，基于flash，因此，无法在ios的浏览器中使用,但是其实时性较好，延时可以低至两秒。 下面是HLS和RTMP协议的对比： 如上两种方案已支持大部分的使用场景，但是，在对实时性要求更高的应用场景，例如，视频监控等，上面两种协议也不能够满足使用要求。下面介绍两种延时更低的方案： RTSP RTSP（实时流协议，Real Time Streaming Protocol）是由Real Network和Netscape共同提出的如何有效地在IP网络上传输流媒体数据的应用层协议。RTSP对流媒体提供了诸如暂停，快进等控制，而它本身并不传输数据，RTSP的作用相当于流媒体服务器的远程控制。 基于RTSP协议，我们可以使用RTP（实时传输协议，Real-time Transport Protocol）来进行流媒体数据的传输，RTP协议具有极低的延时性。在浏览器收到RTP数据包后，视频解析阶段我们可以采用如下两种方案： FFMPEG + WEBGLFFmpeg是一套开源程序，它提供了录制、转换以及流化音视频的完整解决方案。我们可以使用asm或者wasm将FFmpeg转为可在浏览器执行的解码库，通过FFMpeg将经由RTP协议传输的视频数据转码，并通过WEBGL绘制。 使用此种方案有以下优缺点： 在解码能力足够时，播放延时极低，实测可在0.3s以内。 FFMpeg在浏览器端解码，软解极耗性能，1080P下，只能到10帧左右。 asm支持情况较为完善，wasm要在极新版本的浏览器才支持（具体版本需测试） 解码后的数据对开发者来说不再是黑盒，为对视频进行进一步处理提供了便利。 支持H.265解码！目前，基于浏览器直接支持解码的各种方案都不支持H.265解码。 MSEMedia Source Extensions（媒体源扩展）提供了实现无插件且基于 Web 的流媒体的功能。使用 MSE，媒体串流能够通过 JavaScript 创建，并且能通过使用 &lt;audio&gt; 和 &lt;video&gt; 元素进行播放。 在通过拿到RTP包后，我们可以将其组装成fMP4，并喂到video中播放。 使用这种方案，可以解决FFMpeg软解性能不足的问题，实现高分辨率下的流畅播放，在实时性上略差，延时可以控制在1s左右。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"},{"name":"直播","slug":"Javascript/直播","permalink":"http://yoursite.com/categories/Javascript/直播/"}],"tags":[{"name":"H5直播","slug":"H5直播","permalink":"http://yoursite.com/tags/H5直播/"},{"name":"低延时","slug":"低延时","permalink":"http://yoursite.com/tags/低延时/"},{"name":"H264","slug":"H264","permalink":"http://yoursite.com/tags/H264/"},{"name":"视频","slug":"视频","permalink":"http://yoursite.com/tags/视频/"},{"name":"H265","slug":"H265","permalink":"http://yoursite.com/tags/H265/"}]},{"title":"浅谈深拷贝和浅拷贝","slug":"浅谈深拷贝和浅拷贝","date":"2018-05-27T13:25:42.000Z","updated":"2018-05-29T14:19:53.548Z","comments":true,"path":"2018/05/27/浅谈深拷贝和浅拷贝/","link":"","permalink":"http://yoursite.com/2018/05/27/浅谈深拷贝和浅拷贝/","excerpt":"","text":"待补坑…….","categories":[],"tags":[]},{"title":"canvas标签width和style.width的区别","slug":"canvas标签width和style-width的区别","date":"2018-05-26T12:46:01.000Z","updated":"2018-05-29T13:45:58.677Z","comments":true,"path":"2018/05/26/canvas标签width和style-width的区别/","link":"","permalink":"http://yoursite.com/2018/05/26/canvas标签width和style-width的区别/","excerpt":"Canvas大小的修改有三种方法：","text":"Canvas大小的修改有三种方法：方法一： 通过CSS样式来控制canvas元素，具体代码如下： 1canvas &#123; width: 600px; height: 300px&#125; 方法二： 直接在canvas标签内定义width和height，具体代码如下： 1&lt;canvas width='600' height='300'&gt;&lt;/canvas&gt; 方法三： 在JS代码里面设置width和height， 在var ctx = myCanvas.getContext(&#39;2d&#39;) 后面追加如下代码： 12myCanvas.width = 600;myCanvas.height = 300; 设置canvas标签css的width属性，和直接设置canvas的width属性，结果是不一样的。原因如下： canvas标签包含元素本身以及元素绘图表面，它们各自有自己的尺寸大小。当直接设置canvas标签的width时，会同时改变元素本身的大小和元素绘图表面的大小，此时，显示效果不发生改变(只有等比例变化)；设置canvas css中width的属性时，只改变canvas本身的大小，而不改变元素绘图表面的大小，此时，元素绘图表面为适应canvas元素的尺寸，会进行拉伸或缩小，导致显示效果变化。 height 和 style.height 同理。 感谢 ‘https://www.cnblogs.com/regina1123/p/6234719.html&#39;","categories":[{"name":"html","slug":"html","permalink":"http://yoursite.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]}